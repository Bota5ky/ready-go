1. 数据读取

   + 只读打开文件（原话：`打开输入文件时，要使用只读方式打开文件，否者打开文件会失败。`），每次读一个`byte`，判断`byte`是否是`EOF`，给的测试文件都是行开头是`EOF`，并不是行末尾。

   + `123,346,` `num=num*10+byte-'0'`，读到第二个`,`，换到下一行（或者一直读到`\n`）。

2. 模型建立

   + ①矩阵 ②邻接表 ③链表 （ID是否连续，范围uint32[1,2147483647]，原话：`ID和转账金额都为32位的正整数，且小于2的31次方，选手可以不用考虑范围之外的输入。`）

   + ```golang
     type account struct {
     	ID        int
     	next      []*account //原话：每个账号平均转账记录数< 10
     	//visited   bool
     }
     ```
     其中`next`按从小到大排序，使得输出按字典序，`sort.Slice`方法

     必须要有所有ID的`map[ID]-->&account`，读入每行ID的时候判断是否存在，不存在则创建，建立连接

3. 算法

   ①找到所有ID中最小的，堆排序（需要用到一个切片储存所有[]*account）

   ②最小ID区域用Kosaraju's algorithm分割强连通图SCCs，时间复杂度O(V+E)，遍历二次，同时对节点next排序

   ③用Johnson's Algorithm找环路

4. 数据输出

   + 空出第一行，用来最后`rewind`到开头，输出环的`count`
   + 每找到一个环输出一行，行末加上换行符`\n`

5. 可优化点
   
   + 过滤已处理的点

# 华为软件精英挑战赛-2020-初赛-题目分析

[![Martin](https://pic1.zhimg.com/v2-0dc9ac7f805455e98cfb0990ce19a8bd_xs.jpg)](https://www.zhihu.com/people/martin20150405)

[Martin](https://www.zhihu.com/people/martin20150405)

关注他

4 人赞同了该文章

题意：给定一个有向图，求出图中所有长度在[3,7]之间的环。

输入：格式为[IDU,IDV,~]的边表，ID为32位无符号整数，边最多28W条，不重复，结点平均度数小于10（感谢评论区提醒）。环为简单环，个数不大于300W。

输出：环的个数，按照1.环长度；2.环的数字字典序输出所有环。

举个例子：1,2,3的全连接图有两个环



初步思路（Updated on 200405）：

- 重映射所有结点序号为[0,n)
- 用拓扑排序删去一部分点（入度为0，或出度为0的点可以删去，直到没有满足条件的点）
- 搜索，剪枝（深度、字典序），这里有很大的优化空间
- 哎IO好慢呀，求大佬指点优化方法
- 关于换行应该是CRLF还是LF，是否会引起错误还有待观察

先贴一个在100万环【E28W N30000 A1004812】的数据集上要跑几分钟的Baseline，不保证完全正确（仅供思路参考，不要拿去提交哦）

[https://paste.ubuntu.com/p/3gBwyNbw2w/paste.ubuntu.com](https://paste.ubuntu.com/p/3gBwyNbw2w/)

参考资料：

1.数据生成.[https://github.com/byl0561/HWco](https://github.com/byl0561/HWcode2020-TestData)











# 有向图中的所有环--深度遍历暴力求解
原创柯西等式 最后发布于2020-04-05 09:43:01 阅读数 1479  收藏
展开
华为软件精英挑战赛2020题目

为了方便理解题目，暴力求解了一下。。。

每个点都进行深度遍历，找到以这个点为起点的环。。。数据再大一点应该就不行了。。。

代码写得烂，仅供参考。。

更新，用邻接表来实现速度快了100倍。。。

![img](https://img-blog.csdnimg.cn/20200402194503399.png)

更新，根据大佬的Java代码写了两个小的数据集。。。

https://github.com/izhangrui/HWcode2020-TestData/tree/master/C%2B%2B

更新，数据连通性太强了，拓扑排序只能去除一两个点，看情况使用。。。。

同一份代码，为什么用vs跑要比g++快？

![img](https://img-blog.csdnimg.cn/20200405094618286.png)

![img](https://img-blog.csdnimg.cn/20200405100708340.png)

100w的数据排序用太长时间了。。。是不是可以考虑排序用多线程。。。

更新，g++慢是因为编译的时候没加优化选项-O3。。。

试了一下鲲鹏服务器，感觉和笔记本差不多。。。

![img](https://img-blog.csdnimg.cn/20200406002541850.png)

![img](https://img-blog.csdnimg.cn/20200406002606120.png)

看这个100w和300w的结果，这用时和环数呈正比？

另外排序慢很有可能是因为生成的数据高度有序？快排貌似对有序的数据很慢。。。

 

更新，貌似可以省去对结果排序。。。
————————————————
版权声明：本文为CSDN博主「柯西等式」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zhangruijerry/article/details/105268377







# 华为软件精英挑战赛-2020-初赛-题目分析/算法Baseline （求出有向图中所有的环）

[![Martin](https://pic1.zhimg.com/v2-0dc9ac7f805455e98cfb0990ce19a8bd_xs.jpg)](https://www.zhihu.com/people/martin20150405)

[Martin](https://www.zhihu.com/people/martin20150405)

关注他

27 人赞同了该文章

**题意：**给定一个有向图，求出图中所有长度在[3,7]之间的环。

**输入：**格式为[IDU,IDV,~]的边表，ID为32位无符号整数（当然题目说明了，小于2^31，所以int32就好），边最多28W条，不重复，结点平均度数小于10。环中同一个ID不可以重复出现（若大环包括小环，则需要分开统计），环的个数不大于300W。

**输出：**环的个数，按照1.环长度；2.环的数字字典序输出所有环。

举个例子：1,2,3的全连接图有两个环

**初步思路（Updated on 200407）：**

- 要避免搜索出的路径重复，需要制定一个环的标准型，以题目为例，就是最小的ID在环表示的首位
- 题目要求最小的结点在每个路径的第一位，故对ID排序后，重映射所有结点序号为[0,n)，在搜索时，如果直接对某个结点的出边从小到大搜索，最后得到的答案自然是排好序的（虽然排序一遍答案花掉的时间也不多）
- 用拓扑排序删去一部分点（入度为0，或出度为0的点可以删去，直到没有满足条件的点）
- 搜索，剪枝（深度在3-7之间、每次访问的结点ID都应该大于起点的ID），这里有很大的优化空间
- 关于换行应该是CRLF（\r\n）还是LF（\n），官方表示都没有关系

先贴一个在100万环【E28W N30000 A1004812】的数据集上要跑几分钟的Baseline，不保证完全正确（仅供思路参考，不要拿去提交哦）

[https://paste.ubuntu.com/p/3gBwyNbw2w/paste.ubuntu.com](https://paste.ubuntu.com/p/3gBwyNbw2w/)

在极限情况下，IO的耗时（主要是输出文件比较大）若使用ofstream大概在8s左右（这时间比大佬跑两次还要慢QAQ），使用fwrite大概在3s左右（文件~240MB），主要时间还是耗费在答案的寻找上

**改进思路：**

- 问题的更优解法
- 并行求解，平台代码优化（评测姬4C16G）
- IO优化

**初步优化思路（**Updated on 200407**）：**

大佬们总是在炫耀运行时间，让我们这种菜鸡情何以堪

在暴力膜的基础上，该如何进行优化？

通过观察不难发现，在比较稠密的图上，长度为N的环的数量相比长度为N-1的环的数量是指数增长的（和结点的平均度数有关）。

如果能通过只搜索到第6层，而非第7层就得到所有的解，就能够将运行的时间有效的缩减到原先的1/6左右。

我们定义如下的数据结构：

vector<unordered_map<int,vector<int>>> P2;

使用P2[i][j][k]来表示结点i到达结点j，中间经过结点k的路径详情，如果k不在我们已经搜索过的节点列表中，并且j是起点，那么i-k-j就是符合要求的路径的一部分。

具体来说，就是提前做深度为2的搜索（保存最后一层节点的入边），在第6层时直接根据现有结果进行判断，不进入第七层。

按照这个Naive的思路来进行优化，我们可以得到如下的解决方案：

[Ubuntu Pastebinpaste.ubuntu.com](https://paste.ubuntu.com/p/J4pKx28f8y/)

代码实现的复杂度是和节点数与当前节点所能到达的节点数相关的（主要是作者写的太挫了），在一些自制的测试数据集上，算法的单线程（I5-7200U MinGW32）表现为：

- E28W N30000 A1004812 22s
- E28W N25700 A2896262 38s
- E28W N25000 A3512444 45s



为了防止世界被破坏，正式提交开始后，不再提供代码分享。



欢迎大佬们私信、留言来交流指点解题思路。



参考资料：

1.数据生成.[https://github.com/byl0561/HWco](https://github.com/byl0561/HWcode2020-TestData)